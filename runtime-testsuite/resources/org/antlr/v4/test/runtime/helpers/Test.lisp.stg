(ql:quickload "antlr4cl")

(shadowing-import 'antlr4-runtime:exit)
(use-package :antlr4-runtime)

(load "<lexerName>.lisp")
<if(parserName)>
(load "<parserName>.lisp")
<if(useListener)>
(load "<parserName>-listener.lisp")
<endif>
<if(useVisitor)>
(load "<parserName>-visitor.lisp")
<endif>

(defclass tree-shape-listener (parse-tree-listener))

(defmethod enter ((listener tree-shape-listener) (ctx parser-rule-context))
  (dotimes (i (child-count ctx))
    (let* ((child (get-child ctx i))
           (parent (parent-context child)))
      (when (or (not (eq (rule-context parent) ctx)) (not (typep parent rule-node)))
        (error "Invalid parse tree shape detected.")))))
<endif>

(with-open-file (f (car (uiop:command-line-arguments)))
  (let* ((input (make-instance 'antlr4-runtime:char-stream f))
  	     (lexer (make-instance '<lexerName> input))
  	     (stream (make-instance 'antlr4-runtime:common-token-stream lexer))
  	     parser)
    <if(parserName)>
      (setf parser (make-instance '<parserName> stream))
    <if(showDiagnosticErrors)>
      (antlr4-runtime:add-error-listener parser (make-instance 'antlr4-runtime:diagnostic-error-listener))
    <endif>
      (setf (antlr4-runtime:prediction-mode (antlr4-runtime:interpreter parser))
            'antlr4-runtime:+prediction-mode-<predictionMode>+)
    <if(!buildParseTree)>
      (setf (antlr4-runtime:build-parse-trees? parser) nil)
    <endif>
      (let ((tree (<parserStartRuleName> parser)))
        (antlr4-runtime:walk +default-parse-tree-walker+ (make-instance 'antlr4-runtime:tree-shape-listener) tree))
    <else>
      (antlr4-runtime:fill stream)
      (dolist (t (stream-tokens stream))
        (print t))
    <if(showDFA)>
      (print (to-lexer-string (aref (antlr4-runtime:decision-to-dfa (antlr4-runtime:interpreter lexer)) antlr4-runtime:+default-mode+)))
    <endif>
    <endif>))
